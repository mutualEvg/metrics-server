package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

type structInfo struct {
	name    string
	fields  []*ast.Field
	pkg     string
	pkgPath string
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Get the root directory (project root)
	rootDir := "."
	if len(os.Args) > 1 {
		rootDir = os.Args[1]
	}

	// Scan all packages
	structsByPackage, err := scanPackages(rootDir)
	if err != nil {
		return fmt.Errorf("failed to scan packages: %w", err)
	}

	// Generate reset methods for each package
	for pkgPath, structs := range structsByPackage {
		if len(structs) == 0 {
			continue
		}

		if err := generateResetFile(pkgPath, structs); err != nil {
			return fmt.Errorf("failed to generate reset file for package %s: %w", pkgPath, err)
		}

		fmt.Printf("Generated reset.gen.go for package %s (%d structs)\n", structs[0].pkg, len(structs))
	}

	if len(structsByPackage) == 0 {
		fmt.Println("No structs with // generate:reset comment found")
	}

	return nil
}

func scanPackages(rootDir string) (map[string][]structInfo, error) {
	structsByPackage := make(map[string][]structInfo)

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip vendor and hidden directories
		if info.IsDir() {
			name := info.Name()
			// Don't skip the root directory (.)
			if name != "." && (name == "vendor" || name == ".git" || strings.HasPrefix(name, ".")) {
				return filepath.SkipDir
			}
			return nil
		}

		// Only process .go files (skip generated files and test files for scanning)
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, ".gen.go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		structs, err := findStructsInFile(path)
		if err != nil {
			return fmt.Errorf("failed to process file %s: %w", path, err)
		}

		if len(structs) > 0 {
			pkgPath := filepath.Dir(path)
			structsByPackage[pkgPath] = append(structsByPackage[pkgPath], structs...)
		}

		return nil
	})

	return structsByPackage, err
}

func findStructsInFile(filePath string) ([]structInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var structs []structInfo
	pkgPath := filepath.Dir(filePath)

	// Create a map of positions to comments
	commentMap := ast.NewCommentMap(fset, node, node.Comments)

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// Check if this declaration has the generate:reset comment
			if hasGenerateResetComment(genDecl, commentMap) {
				structs = append(structs, structInfo{
					name:    typeSpec.Name.Name,
					fields:  structType.Fields.List,
					pkg:     node.Name.Name,
					pkgPath: pkgPath,
				})
			}
		}
	}

	return structs, nil
}

func hasGenerateResetComment(decl *ast.GenDecl, commentMap ast.CommentMap) bool {
	comments := commentMap[decl]
	for _, commentGroup := range comments {
		for _, comment := range commentGroup.List {
			text := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
			if strings.Contains(text, "generate:reset") {
				return true
			}
		}
	}

	// Also check Doc comments directly on the declaration
	if decl.Doc != nil {
		for _, comment := range decl.Doc.List {
			text := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
			if strings.Contains(text, "generate:reset") {
				return true
			}
		}
	}

	return false
}

func generateResetFile(pkgPath string, structs []structInfo) error {
	var buf bytes.Buffer

	// Write package declaration
	fmt.Fprintf(&buf, "// Code generated by cmd/reset. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", structs[0].pkg)

	// Generate Reset method for each struct
	for _, s := range structs {
		generateResetMethod(&buf, s)
		buf.WriteString("\n")
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, print the unformatted code for debugging
		fmt.Fprintf(os.Stderr, "Warning: failed to format generated code: %v\n", err)
		fmt.Fprintf(os.Stderr, "Unformatted code:\n%s\n", buf.String())
		return err
	}

	// Write to file
	outputPath := filepath.Join(pkgPath, "reset.gen.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return err
	}

	return nil
}

func generateResetMethod(buf *bytes.Buffer, s structInfo) {
	// Generate method signature
	fmt.Fprintf(buf, "func (receiver *%s) Reset() {\n", s.name)
	fmt.Fprintf(buf, "\tif receiver == nil {\n")
	fmt.Fprintf(buf, "\t\treturn\n")
	fmt.Fprintf(buf, "\t}\n\n")

	// Generate reset logic for each field
	for _, field := range s.fields {
		if len(field.Names) == 0 {
			// Embedded field, skip for now
			continue
		}

		for _, name := range field.Names {
			fieldName := name.Name
			resetCode := generateResetCode(fieldName, field.Type)
			if resetCode != "" {
				buf.WriteString(resetCode)
			}
		}
	}

	fmt.Fprintf(buf, "}\n")
}

func generateResetCode(fieldName string, fieldType ast.Expr) string {
	var buf bytes.Buffer

	switch t := fieldType.(type) {
	case *ast.Ident:
		// Basic types: int, string, bool, etc.
		zeroValue := getZeroValue(t.Name)
		if zeroValue != "" {
			fmt.Fprintf(&buf, "\treceiver.%s = %s\n", fieldName, zeroValue)
		}

	case *ast.StarExpr:
		// Pointer type
		fmt.Fprintf(&buf, "\tif receiver.%s != nil {\n", fieldName)
		// Check if the pointed-to type might have a Reset() method
		// Try to call Reset() if it exists, otherwise use zero value
		fmt.Fprintf(&buf, "\t\tif resetter, ok := interface{}(receiver.%s).(interface{ Reset() }); ok {\n", fieldName)
		fmt.Fprintf(&buf, "\t\t\tresetter.Reset()\n")
		fmt.Fprintf(&buf, "\t\t} else {\n")
		// Generate the reset code for the dereferenced pointer
		zeroValue := getZeroValueForType(t.X)
		if zeroValue != "" {
			fmt.Fprintf(&buf, "\t\t\t*receiver.%s = %s\n", fieldName, zeroValue)
		}
		fmt.Fprintf(&buf, "\t\t}\n")
		fmt.Fprintf(&buf, "\t}\n")

	case *ast.ArrayType:
		if t.Len == nil {
			// Slice
			fmt.Fprintf(&buf, "\treceiver.%s = receiver.%s[:0]\n", fieldName, fieldName)
		} else {
			// Array - reset each element
			// For simplicity, we'll skip arrays or handle them as zero value
			fmt.Fprintf(&buf, "\treceiver.%s = [%s]%s{}\n", fieldName, exprToString(t.Len), exprToString(t.Elt))
		}

	case *ast.MapType:
		// Map - use clear
		fmt.Fprintf(&buf, "\tclear(receiver.%s)\n", fieldName)

	case *ast.StructType:
		// Inline struct - reset to zero value
		fmt.Fprintf(&buf, "\treceiver.%s = struct{}{}\n", fieldName)

	case *ast.SelectorExpr:
		// Qualified type (e.g., time.Time)
		// Reset to zero value
		fmt.Fprintf(&buf, "\treceiver.%s = %s{}\n", fieldName, exprToString(t))

	default:
		// For other types, try to reset to zero value
		fmt.Fprintf(&buf, "\treceiver.%s = %s{}\n", fieldName, exprToString(fieldType))
	}

	return buf.String()
}

func getZeroValue(typeName string) string {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64":
		return "0"
	case "uint", "uint8", "uint16", "uint32", "uint64", "uintptr":
		return "0"
	case "float32", "float64":
		return "0"
	case "string":
		return `""`
	case "bool":
		return "false"
	case "byte":
		return "0"
	case "rune":
		return "0"
	case "complex64", "complex128":
		return "0"
	default:
		// For custom types, use zero value syntax
		return typeName + "{}"
	}
}

func getZeroValueForType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return getZeroValue(t.Name)
	case *ast.SelectorExpr:
		// Qualified type (e.g., time.Time)
		return exprToString(t) + "{}"
	case *ast.ArrayType:
		if t.Len == nil {
			// Slice - return nil
			return "nil"
		} else {
			// Array
			return exprToString(expr) + "{}"
		}
	case *ast.MapType:
		return "nil"
	case *ast.StructType:
		return exprToString(expr) + "{}"
	default:
		return exprToString(expr) + "{}"
	}
}

func exprToString(expr ast.Expr) string {
	var buf bytes.Buffer
	format.Node(&buf, token.NewFileSet(), expr)
	return buf.String()
}
